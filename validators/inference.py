import cv2
import numpy as np
import os
from core.logger import log_info, log_warning, log_error, log_success

def validate_with_opencv(onnx_path, input_shape, source_mode='darknet'):
    log_info("Initializing OpenCV DNN validation...")
    
    batch, channels, height, width = input_shape
    
    if not os.path.exists(onnx_path):
        log_error(f"ONNX file not found for OpenCV validation: {onnx_path}")
        return False

    try:
        import onnx
        onnx_model = onnx.load(onnx_path)
        unsupported_ops = set()
        for node in onnx_model.graph.node:
            if node.op_type in ['ScatterND', 'Gather', 'GatherElements']:
                unsupported_ops.add(node.op_type)
        
        if unsupported_ops:
            ops_str = ", ".join(sorted(list(unsupported_ops)))
            log_error(f"OpenCV DNN cannot process this model because it contains unsupported operators: {ops_str}")
            
            if source_mode == 'darknet':
                log_error("These operators are usually generated by YOLO decoding logic.")
                log_error("If you converted this Darknet model with UniversalONNXConverter, use --no-yolo-layer for a clean export.")
            else:
                log_error("These operators are usually generated by YOLO decoding logic (Decoded Boxes).")
                log_error("OpenCV DNN does not support these layers. This is normal for PyTorch models with built-in decoding.")
            return False

        net = cv2.dnn.readNetFromONNX(onnx_path)
        net.setPreferableBackend(cv2.dnn.DNN_BACKEND_OPENCV)
        net.setPreferableTarget(cv2.dnn.DNN_TARGET_CPU)
        
        current_dir = os.path.dirname(os.path.abspath(__file__))
        test_image = os.path.join(current_dir, "data", "dog.jpg")
        
        if os.path.exists(test_image):
            img = cv2.imread(test_image)
            log_info(f"Using test image: {test_image}")
        else:
            log_warning(f"Test image not found at {test_image}. Using random data.")
            img = np.random.randint(0, 255, (height, width, channels), dtype=np.uint8)

        blob = cv2.dnn.blobFromImage(img, 1/255.0, (width, height), swapRB=True, crop=False)
        
        net.setInput(blob)
        
        out_names = net.getUnconnectedOutLayersNames()
        outputs = net.forward(out_names)
        
        log_info(f"OpenCV DNN inference successful with {len(outputs)} output(s).")
        
        all_ok = True
        for i, out in enumerate(outputs):
            max_val = np.max(out)
            mean_val = np.mean(out)
            log_info(f"Output {i} -> Shape: {out.shape}, Max: {max_val:.6f}, Mean: {mean_val:.6f}")
            
            if np.isnan(max_val) or np.isinf(max_val):
                log_error(f"Output {i} contains invalid values (NaN/Inf).")
                all_ok = False
            elif max_val == 0 and mean_val == 0:
                log_warning(f"Output {i} is all zeros. Possible dead model or incorrect weights.")
        
        if all_ok:
            log_success("OpenCV DNN validation passed.")
        return all_ok

    except Exception as e:
        msg = str(e)
        if "cv2.error" in msg or "Assertion failed" in msg:
             log_error("ONNX inference cannot be performed because of the YOLO layer.")
             log_error("OpenCV DNN module has limited support for the complex operations used in the decoding layer.")
             log_error("This does NOT mean the model is broken; it just means OpenCV cannot run it.")
             #log_error(f"Detailed Error: {msg.splitlines()[0]}")
        else:
             log_error(f"OpenCV DNN validation failed: {msg}")
        return False
